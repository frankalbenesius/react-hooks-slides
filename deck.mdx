import { themes, Split } from "mdx-deck";
console.log(themes.swiss);
export const theme = {
  ...themes.swiss,
  ...themes.prism,
  styles: {
    ...themes.swiss.styles,
    code: {
      ...themes.swiss.styles.code,
      fontSize: "1.5rem"
    }
  }
};

import {RoomAvailable, RoomAvailableHook, TwoOneSplit} from "./components";

# React Hooks

a Lunch & Learn
by Katie & Frank

---

# Who Is This For?

You know some React.

You've probably heard of Hooks, but you want to know more about them.

_...insert-gif_

---

# The Heck Are Hooks?

They are functions.

They let you use state and other React features without writing a class.

---

# Why do they exist?

Sometimes React is annoying:
  - complicated & long class components
  - complicated patterns like "Render Props"

They also can make code more "reusable".

---

# useState

Returns a stateful value, and a function to update it.

```jsx
const [state, setState] = useState(initialState);
```

---

### useState - without hooks

<TwoOneSplit>

```jsx
class Room extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isAvailable: props.room.isAvailable
    };
  }
  render() {
    return (
      <div>
        <div>{this.state.isAvailable ? "OPEN" : "Not Available}</div>
        <button
          onClick={() => this.setState({ isAvailable: false })}>
          Book
        </button>
      </div>
    );
  }
}
```

<RoomAvailable room={{isAvailable: true}} />

</TwoOneSplit>

---

### useState - with hook

<TwoOneSplit>

```jsx
import React, { useState } from "react";

function RoomAvailableHook ({room}) {
  const [isAvailable, setIsAvailable] = useState(room.isAvailable);

  return (
    <div>
      <div>{isAvailable ? "OPEN" : "Not Available"}</div>
        <button onClick={() => setIsAvailable(false)}>
            Book
        </button>
    </div>
  );
}
```

<RoomAvailableHook room={{isAvailable: true}} />

</TwoOneSplit>

---

# useEffect

A place to put side effects like mutations, fetching, subscriptions, timers, and logging.

Runs after every component render. Replacing class lifecycle methods.

```jsx
useEffect(() => {
  // do this thing after render
})
```

---

### useEffect - without hooks

<TwoOneSplit>
```jsx
const () =>
```
<div></div>

</TwoOneSplit>

---

### useEffect - with hook

```jsx
import React, { useEffect } from "react";

function Page({ selectedRoom, children }) {
  useEffect(() => {
    if (loggedIn) {
      document.title = "Online";
    }
  }, [loggedIn]);

  return <div>{children}</div>;
}
```

---

# useEffect - Fetch with Class

---

# useEffect - Fetch with Hook

_TODO: replace with fetching rooms_

```jsx
import React, {useEffect} from "react";

function CharacterList() {

  const [characters, setCharacters] = useState([]);

  useEffect(() => {
    fetch("url").then(data =>
      setCharacters(data);
    )}
  })

  return (
    <div>
      {characters.map(character => (
        <div>{character.name}</div>
      ))}
    </div>
  );
}
```

---

# Writing Custom Hooks

Intra-component logic is now composable.

todo: an example that shows how a set of a few hooks could be abstracted and packaged together into their own, more meaningful hook

_TODO: maybe move after useEffect & before useReducer or useContext_


---

# useReducer

An alternative to useState. Accepts a reducer and returns the current state paired with a dispatch method.

```jsx
const [state, dispatch] = useReducer(reducer, initialState);
```

---

# useReducer Example

```jsx
const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <>
      Count: {state.count}
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
    </>
  );
}
```

---

# Wait!

This looks a lot like Redux... ?

---

# useContext

Accepts a context object and returns the current context value for that context.

```jsx
const MyContext = React.createContext("some value");

// and then, in a function component:
const value = useContext(MyContext); // "some value"
```

---

# Can Replace Redux

useContext combined with useReducer makes a pseudo-redux.

TODO: link to code sandbox with deeply nested dispatch context

_TODO: maybe talk about rooms & room events COULD be in a global store_


---

# 3rd Party Hooks

NPM ain't just for components anymore.

TODO: gif

- useDebounce
- useMedia? // find better example
- useSWR // or not zeit version

---

# Final Thoughts

- Other hooks exist:
  - useCallback
  - useMemo
  - etc

---

## The End
